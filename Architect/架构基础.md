# 架构基础
<!-- @author DHJT 2020-05-14 -->
《大型网站技术架构:核心原理与案例分析》

并行和并发区别

1、并行是指两者同时执行一件事，比如赛跑，两个人都在不停的往前跑；
2、并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率

## 软件架构技术

### 多租户技术(multi-tenancy technology)
或称多重租赁技术，是一种软件架构技术，它是在探讨与实现如何于多用户的环境下共用相同的系统或程序组件，并且仍可确保各用户间数据的隔离性。
多租户简单来说是指一个单独的实例可以为多个组织服务。多租户技术为共用的数据中心内如何以单一系统架构与服务提供多数客户端相同甚至可定制化的服务，并且仍然可以保障客户的数据隔离。一个支持多租户技术的系统需要在设计上对它的数据和配置进行虚拟分区，从而使系统的每个租户或称组织都能够使用一个单独的系统实例，并且每个租户都可以根据自己的需求对租用的系统实例进行个性化配置。
多租户技术可以实现多个租户之间共享系统实例，同时又可以实现租户的系统实例的个性化定制。通过使用多租户技术可以保证系统共性的部分被共享，个性的部分被单独隔离。通过在多个租户之间的资源复用，运营管理维护资源，有效节省开发应用的成本。而且，在租户之间共享应用程序的单个实例，可以实现当应用程序升级时，所有租户可以同时升级。同时，因为多个租户共享一份系统的核心代码，因此当系统升级时，只需要升级相同的核心代码即可。
目的：共用相同的系统或程序组件
要求：确保各用户间数据的隔离性

### 基础
Tomcat集群，Redis共享SESSION处理客户端会话。
LVS+Keepalived
VARNISH
数据库读写分离
Solr、Elasticsearch
MyCat、读库水平拆表，写库垂直拆分
分布式文件系统MongileFS、FastDFS
消息中间件

### 测试之stub和mock
Mock Stub（打桩）

Mock
关注行为验证。细粒度的测试，即代码的逻辑，多数情况下用于单元测试。

Stub
关注状态验证。粗粒度的测试，在某个依赖系统不存在或者还没实现或者难以测试的情况下使用，例如访问文件系统，数据库连接，远程协议等。

Stub和Mock的相同处
stub和mock都是为了配合测试，对被测程序所依赖的单元的模拟。
简单说，为了测函数A，但A有引用到了函数B，通过模拟B的一些状态或行为测试A。
Stub和Mock都是模拟外部依赖，以便我们能控制。

Stub和Mock的区别
stub基于状态，mock基于行为
stub难于维护
mock有对本身的调用验证
stub是基于状态，mock是基于行为。
Stub是完全模拟一个外部依赖， 而Mock用来判断测试通过还是失败

Mock与Stub的区别

Mock:
关注行为验证。细粒度的测试，即代码的逻辑，多数情况下用于单元测试。

何时使用Mock：
真实对象的行为具有不确定性。
真实对象难以创建。
真实对象的行为难以模拟(例如网络错误)。
真实对象运行效率很低。
真实对象有或者是UI。
测试需要得到某个对象列表，但是真实对象必须在某种环境下才能提供。
真实对象还没实现。
Mock的优点：
运行速度快，测试覆盖率高，容易实现且可以形成良好的测试文档。
Mock的缺点：
不是银弹，对于集成测试等粗粒度且耗时的测试不太适用。
Stub：
关注状态验证。粗粒度的测试，在某个依赖系统不存在或者还没实现或者难以测试的情况下使用，例如访问文件系统，数据库连接，远程协议等。

何时用Stub：
需要用到Mock或者Stub的情况，往往是测试的代码存在依赖，当这种依赖难以实现或者不稳定的时候可以考虑使用Stub策略，例如，需要测试的系统，可能需要访问数据库，依赖于运行环境(安全性，存储，Web Service)，或者需要访问远程文件系统，访问远程协议(HTTP，SOAP)等。

由于现存的应用的太复杂或者过于脆弱，修改它需要大量的人天。诸如不同系统之间的集成测试，类属于粗粒度的测试皆可考虑使用Stub。

Stub的优点：
能弥补Mock的不足，能够模拟复杂的测试环境。
Stub的缺点：
Stub往往比较复杂难以实现，而且需要经常性的调试它。
由于Stub模拟的都是难以测试的环境依赖，其复杂性导致它难以维护。
实现Stub并不能提供细粒度的单元测试。
不同的情况需要不同的Stub实现策略。

### 性能测试相关(TPS/RT/PV等)
QPS

Queries Per Second，每秒查询数。每秒能够响应的查询次数。
QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。每秒的响应请求数，也即是最大吞吐能力。
TPS

Transactions Per Second 的缩写，每秒处理的事务数目。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息作出的评估分。

TPS 的过程包括：客户端请求服务端、服务端内部处理、服务端返回客户端。
例如，访问一个 Index 页面会请求服务器 3 次，包括一次 html，一次 css，一次 js，那么访问这一个页面就会产生一个“T”，产生三个“Q”。

PV（page view）即页面浏览量，通常是衡量一个网络新闻频道或网站甚至一条网络新闻的主要指标。
PV 即 page view，页面浏览量。用户每一次对网站中的每个页面访问均被记录 1 次。用户对同一页面的多次刷新，访问量累计。

根据这个特性，刷网站的 PV 就很好刷了。

与 PV 相关的还有 RV，即重复访问者数量（repeat visitors）。

UV 访问数（Unique Visitor）指独立访客访问数，统计1天内访问某站点的用户数(以 cookie 为依据)，一台电脑终端为一个访客。

IP（Internet Protocol）独立 IP 数，是指 1 天内多少个独立的 IP 浏览了页面，即统计不同的 IP 浏览用户数量。同一 IP 不管访问了几个页面，独立 IP 数均为 1；不同的 IP 浏览页面，计数会加 1。IP 是基于用户广域网 IP 地址来区分不同的访问者的，所以，多个用户（多个局域网 IP）在同一个路由器（同一个广域网 IP）内上网，可能被记录为一个独立 IP 访问者。如果用户不断更换 IP，则有可能被多次统计。

GMV，是 Gross Merchandise Volume 的简称。只要是订单，不管消费者是否付款、卖家是否发货、是否退货，都可放进 GMV 。

RPS 代表吞吐率，即 Requests Per Second 的缩写。吞吐率是服务器并发处理能力的量化描述，单位是 reqs/s，指的是某个并发用户数下单位时间内处理的请求数。
某个并发用户数下单位时间内能处理的最大的请求数，称之为最大吞吐率。

有人把 RPS 说等效于 QPS。其实可以看作同一个统计方式，只是叫法不同而已。RPS/QPS，可以使用 apche ab 工具进行测量。

#### PV
PV是 Page View的缩写。用户通过浏览器访问页面，对应用服务器产生的每一次请求，
记为一个 PV。淘宝性能测试环境下，将这个概念做了延伸，系统真实处理的一个请求，视
为一个 PV。即，PV的概念也适用于接口。
PV的统计一般可以通过监控埋点或者统计访问日志统计得出。
说到PV还有个特殊的情况，叫PeakPV，指一天中 PV数达到的高峰PV值。
通过一些监控系统，也可以直观看到统计数据。

#### QPS/TPS
QPS/TPS原本含义为：系统每秒能处理的请求/事务的数量，或者说吞吐量。在web应用我们更关注的是web应用每秒能处理的request数量。这个是衡量系统性能的重要指标。
QPS（TPS）= 并发数/平均响应时间。
QPS的统计可以通过访问日志统计对应时间的PV量除以对应时间求得。在性能测试中可以通过工具测试获得。
一般经常统计的是高峰期PV对应的QPS。

#### ResponseTime响应时间
响应时间(RT)是指从客户端发一个请求开始计时，到客户端接收到从服务器端返回的响应结果结束所经历的时间，响应时间由请求发送时间、网络传输时间和服务器处理时间三部分组成。

#### LOAD负载
系统平均负载，被定义为在特定时间间隔内运行队列中的平均进程数。如果一个进程满
足以下条件则其就会位于运行队列中：
-它没有在等待 I/O操作的结果
-它没有主动进入等待状态（也就是没有调用'wait'）
-没有被停止（例如：等待终止）1
这个负载值比较理想的指标值是cpu个数*核数*0.7 ，如果超过长期超过过这个值就需要对系统进行警惕了。

#### CPU 资源
CPU 资源这里指应用服务系统的 CPU 资源占用率。CPU 资源是判断系统处理能力以及应用运行是否稳定的重要参数。

#### JVM GC和FullGC
对于java应用的性能指标必定少不了GC的相关指标了。通常我们的应用应该尽量避免FGC。因为FGC会进行完全的垃圾清理，会使应用运行得很慢，所以需要通过设置合适的JVM参数和GC策略来避免FGC。通常监控的指标有GC次数和响应时间。

常用的性能指标还有内存占用，磁盘io等一些指标；

## 限流算法有漏桶算法和令牌桶算法
令牌桶算法（Token Bucket）：是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。

两者主要区别在于“漏桶算法”能够强行限制数据的传输速率，而“令牌桶算法”在能够限制数据的平均传输速率外，还允许某种程度的突发传输。在“令牌桶算法”中，只要令牌桶中存在令牌，那么就允许突发地传输数据直到达到用户配置的门限，所以它适合于具有突发特性的流量。