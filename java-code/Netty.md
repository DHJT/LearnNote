# Netty 编程
<!-- @author DHJT 2019-10-13 -->
一个提供异步事件驱动网络应用框架和快速开发可维护的高性能高扩展性服务端和客户端协议工具集的成果。
换句话说，Netty是一个 NIO 客户端服务端框架，它使得快速而简单的开发像服务端客户端协议的网络应用成为了可能。它它极大的简化并流线化了如TCP和UDP套接字服务器开发的网络编程。


## AIO/BIO/NIO
阻塞、非阻塞
同步、异步

NIO，即`Non Blocking IO`，非阻塞IO，在JAVA中NIO的核心就是`Selector`机制。简单而言，创建一个Socket Channel，并将其注册到一个Selector上（多路复用器），这个Selector将会“关注”Channel上发生的IO读写事件，并在事件发生（数据就绪）后执行相关的处理逻辑。对于阻塞IO，它需要在read()、write()操作上阻塞而直到数据操作完毕，但是NIO则不需要，只有当Selector检测到此Channel上有事件时才会触发调用read、write操作。

但是NIO并不是严格意义上的“异步IO”（Asynchronous），最大的原因就是Selector本身是阻塞的！！即selector需要通过线程阻塞的方式（其select方法）获取底层通道的事件变更，然后获取SelectionKey列表；那么对于“异步IO”（概念同JDK 7的AIO）在整个操作链路上均不需要任何阻塞（完全基于OS的IO事件），依赖基于事件驱动的Handler做数据处理。目前Netty尚没有集成AIO的相关特性，即Netty本身为非阻塞IO框架。

### 五种 I/O 模型
Richard Stevens 的《UNIX® Network Programming Volume》提到了 5 种 I/O 模型:

1. Blocking I/O (同步阻塞 I/O)
2. Nonblocking I/O（同步非阻塞 I/O）
3. I/O multiplexing（多路复用 I/O）
4. Signal driven I/O（信号驱动 I/O，实际很少用，Java 不支持）
5. Asynchronous I/O (异步 I/O)

### 线程模型
- Reactor单线程模型；
    + 作为NIO服务端，接收客户端的TCP连接；
    + 作为NIO客户端，向服务端发起TCP连接；
    + 读取通信对端的请求或者应答消息；
    + 向通信对端发送消息请求或者应答消息。
- Reactor多线程模型；
    + 有专门一个NIO线程-Acceptor线程用于监听服务端，接收客户端的TCP连接请求；
    + 网络IO操作-读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送；
    + 1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止发生并发操作问题。
- 主从Reactor多线程模型。
    + 为了解决1个服务端监听线程无法有效处理所有客户端连接的性能不足问题，有一组NIO线程处理服务气短的监听。

如上的几种模式，在ServerBootStrap.goup初始化时设置，我们的例子，采用的是主从Reactor多线程模型。

Proactor模式

## `Reactor`/`Proactor`的区别

### 主动和被动
以主动写为例：

Reactor将handle放到select()，等待可写就绪，然后调用write()写入数据；写完处理后续逻辑；
Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑；
可以看出，Reactor被动的等待指示事件的到来并做出反应；它有一个等待的过程，做什么都要先放入到监听事件集合中等待handler可用时再进行操作；
Proactor直接调用异步读写操作，调用完后立刻返回；

### 实现
Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应；

Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）

### 优点
Reactor实现相对简单，对于耗时短的处理场景处理高效；
操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；
事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；
事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来，

Proactor性能更高，能够处理耗时长的并发场景；

### 缺点
Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；

Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现；

### 适用场景
Reactor：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序；
Proactor：异步接收和同时处理多个服务请求的事件驱动程序；
