# 多线程、并发
<!-- @author DHJT 2019-07-08 -->

多线程开发离不开锁机制，现在的Java语言中，提供了2种锁，一种是语言特性提供的内置锁，还有一种是 java.util.concurrent.locks 包中的锁，这篇文章简单整理一下内置锁的知识点。

原子性、内存可见性、volatile
用于解决多线程安全问题的方式
1. 同步代码块
2. 同步方法
3. 同步锁：lock、unlock

## 内置锁（Intrinsic Lock）或监视器锁(Monitor lock)
使用方式就是使用 synchronized 关键字，synchronized 方法或者 synchronized 代码块。

### 锁类型
类锁、对象锁
指定任意对象加锁：
```java
private void function() {
    synchronized (object) {
        //TODO execute something
    }
}
// 此时，这段同步代码块的锁加在object对象上面。该对象可以是当前对象（object == this），也可以是当前类的Class对象（object == MyClass.class）。
```
### 缺点：
- 内置锁在进入同步块时，采取的是无限等待的策略，一旦开始等待，就既不能中断也不能取消，容易产生饥饿与死锁的问题。
- 在线程调用notify方法时，会随机选择相应对象的等待队列的一个线程将其唤醒，而不是按照FIFO（先入先出策略）的方式，如果有强烈的公平性要求，就无法满足。
- Synchronized在JDK1.5及之前性能（主要指吞吐率）比较差，扩展性也不如ReentrantLock。但是JDK1.6以后，修改了管理内置锁的算法，使得Synchronized和标准的ReentrantLock性能差别不大。

## 显示锁(Lock)
ReentrantLock是显示锁，需要显示进行 lock 以及 unlock 操作。

### 基本使用
```java
void lock();  //尝试获取锁,若得不到着等待(不可中断,类似于synchronized方式)
void lockInterruptibly() ; //可中断的尝试获取锁
boolean tryLock();尝试获取锁,不管得到与否立即返回
boolean tryLock(long time, TimeUnit unit)尝试获取锁,若得不到等到一段时间
void unlock();// 释放锁
Condition new Condition();//创建于该锁相关的条件变量,实现精确等待/唤醒
Lock lock = new ReentrantLock();
lock.lock();
try {

} finally {
    lock.unlock();
}
```
相比于Synchronized要复杂一些，而且一定要记得在finally中释放锁而不是其他地方，这样才能保证即使出了异常也能释放锁。

### 虚假唤醒
```java
// wait虚假唤醒问题，可以始终放在循环中
synchronized (obj) {
    while (// <condition does not hold>)
        obj.wait();
    // TODO code
}
```

### 线程间的通信`Condition`
与ReentrantLock搭配的通行方式是`Condition`，如下：
```java
private Lock lock = new ReentrantLock();  
private Condition condition = lock.newCondition(); 
condition.await();// this.wait();  
condition.signal();// this.notify();  
condition.signalAll();// this.notifyAll();
```
Condition是被绑定到Lock上的，必须使用lock.newCondition()才能创建一个Condition。从上面的代码可以看出，Synchronized能实现的通信方式，Condition都可以实现，功能类似的代码写在同一行中。而Condition的优秀之处在于它可以为多个线程间建立不同的Condition，比如对象的读/写Condition，队列的空/满Condition，在JDK源码中的ArrayBlockingQueue中就使用了这个特性：

### 优缺点
- lock.lockInterruptibly() 可以使得线程在等待锁是支持响应中断；lock.tryLock() 可以使得线程在等待一段时间过后如果还未获得锁就停止等待而非一直等待。有了这两种机制就可以更好的制定获得锁的重试机制，而非盲目一直等待，可以更好的避免饥饿和死锁问题。
- ReentrantLock可以成为公平锁（非默认的），所谓公平锁就是锁的等待队列的FIFO，不过公平锁会带来性能消耗，如果不是必须的不建议使用。这和CPU对指令进行重排序的理由是相似的，如果强行的按照代码的书写顺序来执行指令，就会浪费许多时钟周期，达不到最大利用率。
- 虽然Synchronized和标准的ReentrantLock性能差别不大，但是ReentrantLock还提供了一种非互斥的读写锁，也就是不强制每次最多只有一个线程能持有锁，它会避免“读/写”冲突，“写/写”冲突，但是不会排除“读/读”冲突，因为“读/读”并不影响数据的完整性，所以可以多个读线程同时持有锁，这样在读写比较高的情况下，性能会有很大的提升。

### 锁降级/锁升级
Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

## juc
`CountDownLatch`是在java1.5被引入，跟它一起被引入的工具类还有`CyclicBarrier`、`Semaphore`、`ConcurrentHashMap`和`BlockingQueue`。
存在于`java.util.cucurrent`包下。

### ReentrantLock

### 读写锁 ReadWriteLock
java.util.concurrent.locks.ReadWriteLock
java.util.concurrent.locks.ReentrantReadWriteLock
锁降级：从写锁变成读锁；
锁升级：从读锁变成写锁。读锁是可以被多线程共享的，写锁是单线程独占的。也就是说写锁的并发限制比读锁高，这可能就是升级/降级名称的来源。

因为同一个线程中，在没有释放读锁的情况下，就去申请写锁，这属于锁升级，ReentrantReadWriteLock是不支持的。

### 闭锁(CountDownLatch)
一种同步工具，可以延迟线程的进度直到终止状态。可以确保某些任务直到其他任务完成后才继续往下执行。
FutureTask 也可以用作闭锁
```java
//参数count为计数值
public CountDownLatch(int count) {  };
//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
public void await() throws InterruptedException { };
//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行
public boolean await(long timeout, TimeUnit unit) throws InterruptedException { };
//将count值减1
public void countDown() { };

// 模拟并发示例：
public class Parallellimit {
    public static void main(String[] args) {
        ExecutorService pool = Executors.newCachedThreadPool();
        CountDownLatch cdl = new CountDownLatch(100);
        for (int i = 0; i < 100; i++) {
            Runnable runnable = new CountRunnable(cdl);// CountRunnable 为实现 Runnable 接口的类
            pool.execute(runnable);
        }
    }
}
```

### Exchanger

### 栅栏(CyclicBarrier)

### 信号量(Semaphore)
`Semaphore` 是一个计数信号量，必须由获取它的线程释放。
常用于限制可以访问某些资源的线程数量，例如通过 Semaphore 限流。

Semaphore 只有3个操作：
- 初始化 Semaphore semaphore = new Semaphore(3);
- 增加 semaphore.acquire();
- 减少 semaphore.release();


### CountDownLatch和CyclicBarrier区别：
1. CountDownLatch是一个计数器，线程完成一个记录一个，计数器递减，只能只用一次
2. CyclicBarrier的计数器更像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供reset功能，可以多次使用

## 线程池

|-Java.util.concurrent.Executor 负责线程的使用与调度的根接口
  |-ExecutorService:Executor的子接口，线程池的主要接口
    |-AbstractExecutorService:实现了ExecutorService接口，基本实现了ExecutorService其中声明的所有方法，另有添加其他方法
      |-ThreadPoolExecutor:继承了AbstractExecutorService，主要的常用实现类
    |-ScheduledExecutorService:继承了ExecutorService，负责线程调度的接口
      |-ScheduledThreadPoolExecutor:继承了ThreadPoolExecutor同时实现了ScheduledExecutorService


- Executors
    + ExecutorService newFiexedThreadPool(int Threads) 创建固定数目线程的线程池。
    + ExecutorService newCachedThreadPool()：创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果没有可用的线程，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。
    + ExecutorService newSingleThreadExecutor()：创建一个单线程化的Executor。
    + ScheduledExecutorService newScheduledThreadPool(int corePoolSize)：创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。

## Executors 与 ThreadPoolExecutor（阿里发布的 Java开发手册中强制线程池不允许使用 Executors 去创建）[^2]
java并发编程：Executor、Executors、ExecutorService

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler);
```

- 强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。

- Executor 和 ExecutorService 这两个接口主要的区别是：ExecutorService 接口继承了 Executor 接口，是 Executor 的子接口
- Executor 和 ExecutorService 第二个区别是：Executor 接口定义了 execute()方法用来接收一个Runnable接口的对象，而 - ExecutorService 接口中的 submit()方法可以接受Runnable和Callable接口的对象。
- Executor 和 ExecutorService 接口第三个区别是 Executor 中的 execute() 方法不返回任何结果，而 ExecutorService 中的 - submit()方法可以通过一个 Future 对象返回运算结果。
- Executor 和 ExecutorService 接口第四个区别是除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。比如：调用 - shutDown() 方法终止线程池。可以通过 《Java Concurrency in Practice》 一书了解更多关于关闭线程池和如何处理 pending 的任务的知识。
- Executors 类提供工厂方法用来创建不同类型的线程池。比如: newSingleThreadExecutor() - 创建一个只有一个线程的线程池，newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，newCachedThreadPool()可以根据需要创建新的线程，但如果已有线程是空闲的会重用已有线程。

### 自定义线程池
自定义线程池，可以用ThreadPoolExecutor类创建，它有多个构造方法来创建线程池，用该类很容易实现自定义的线程池


[^1]: [Guava ListenableFuture实现异步非阻塞调用](https://blog.csdn.net/zbw18297786698/article/details/73411762)
[^2]: [Executors与ThreadPoolExecutor（阿里发布的 Java开发手册中强制线程池不允许使用 Executors 去创建）](https://blog.csdn.net/qq_33300570/article/details/78394188)


[1]: https://www.jianshu.com/p/f030aa5d7a28 '线程池之ThreadPoolExecutor使用'